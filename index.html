<!DOCTYPE html>
<html lang="en">
    <head>
        <title>integrera mera</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #ffffff;
                font-family:Monospace;
                font-size:13px;
                text-align:center;

                background-color: #ffffff;
                margin: 0px;
                overflow: hidden;
            }
        </style>
    </head>

    <body>
        <div id="container"></div>
        <div id="info"><a href="http://threejs.org" target="_blank">three.js</a> webgl - interactive - particles</div>

        <script src="js/three.min.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/renderers/CanvasRenderer.js"></script>
        <script src="js/renderers/Projector.js"></script>
        <script src="js/libs/stats.min.js"></script>
        <script src="js/objects/ShadowMesh.js"></script>
         <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>

        <!--SHADERS-->

        <!--Vertex shaders-->

        <script type="x-shader/x-vertex" id="vertexshader">

            attribute float size;
            attribute vec3 customColor;

            varying vec3 vColor;

            void main() {

                vColor = customColor;

                vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

                gl_PointSize = size * ( 300.0 / -mvPosition.z );

                gl_Position = projectionMatrix * mvPosition;

            }

        </script>

        <script type="x-shader/x-fragment" id="fragmentshader">

            uniform vec3 color;
            uniform sampler2D texture;

            varying vec3 vColor;

            void main() {

                gl_FragColor = vec4( color * vColor, 1.0 );

                gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );

                if ( gl_FragColor.a < ALPHATEST ) discard;

            }
        </script>


        <script>

            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            var container, stats;
            var camera, scene, renderer;
            var mouseX = 0, mouseY = 0;
            var group;
            var particle;

            var clock = new THREE.Clock();

            var sunLight = new THREE.DirectionalLight( 'rgb(255,255,255)', 1.5 );
            var useDirectionalLight = true;
            var NormalVector = new THREE.Vector3( 0, 1, 0 );
            var lightPosition4D = new THREE.Vector4();

            var starParticles;
            var raycaster;
            var PARTICLE_SIZE = 20;

            var particles2, sprite, particleMesh, mouse;
            var containerWidth;
            var containerHeight;


            //var mouseVector, projector, constrols;

            var objects = [];
            var particleMaterial, mouse, circle;

            var earthMaterial, earthMesh;

            var INTERSECTED;

            init();
            animate();

            function init() {

                container = document.getElementById( 'container' );

                //TEXT
                var info = document.createElement( 'div' );
                info.style.position = 'absolute';
                info.style.top = '30px';
                info.style.width = '100%';
                info.style.textAlign = 'center';
                //info.style.fontsize = '20px';
                info.style.color = 'white';
                info.innerHTML = 'integreramera';
                container.appendChild( info );


                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
                camera.position.z = 12;
                camera.position.y = 0;
                camera.rotation.x = 40;

                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2( 0xffffff, 0.008 );

                group = new THREE.Group();
                scene.add(group);

                //LIGHT -----------------------------------
                //sunLight.position.set(0.7, 6, 4 );
                sunLight.position.set(0, 110, -40);
                sunLight.lookAt( scene.position );
                group.add( sunLight );

                lightPosition4D.x = sunLight.position.x;
                lightPosition4D.y = sunLight.position.y;
                lightPosition4D.z = sunLight.position.z;
                lightPosition4D.w = 0.001; // must be slighty greater than 0, due causing matrixinverse errors

                //EARTH ------------------------------------------------
                var earthGeometry = new THREE.SphereGeometry(10, 50, 50);
                earthGeometry.castShadow = true;
                earthGeometry.receiveShadow = false;

                earthMaterial = new THREE.MeshPhongMaterial({
                    map: THREE.ImageUtils.loadTexture('images/nasa.jpg'),
                    //color: 0x99ccff,
                    overdraw: 0.5,
                    bumpMap: THREE.ImageUtils.loadTexture('images/earthbump1k.jpg'),
                    bumpScale: 0.5,
                    specularMap: THREE.ImageUtils.loadTexture('images/earthspec1k.jpg'),
                    specular: new THREE.Color('black')
                });
                earthMesh = new THREE.Mesh( earthGeometry, earthMaterial );
                earthMesh.position.y = -11;

                group.add ( earthMesh );

                //TEXT ------------------------------------------------
                // var text = new THREE.TextGeometry('hej', font: "helvetiker" , size: 5);
                // scene.add(text);
               
                //Background PARTICLES ----------------------------------------------- Kan förenklas
                var starPositions = new Float32Array(1000 * 3);
                var starColors = new Float32Array(1000 * 3);
                var starSizes = new Float32Array(1000 * 3);

                var starColor = new THREE.Color();

                for ( var i = 0; i < 1000; i ++ ) {

                    var vertex = new THREE.Vector3();

                    vertex.x = Math.random() * 1000 - 500;
                    vertex.y = Math.random() * 1000 - 500;
                    vertex.z = Math.random() * 1000 - 500;
                   
                    vertex.toArray( starPositions, i * 3 );

                    starColor.setHSL( 255, 255, 255 )
                    starColor.toArray( starColors, i * 3 );

                    starSizes[ i ] = PARTICLE_SIZE * 0.4;
                }

                var bStars = new THREE.BufferGeometry();
                bStars.addAttribute( 'position', new THREE.BufferAttribute( starPositions, 3 ) );
                bStars.addAttribute( 'customColor', new THREE.BufferAttribute( starColors, 3 ) );
                bStars.addAttribute( 'size', new THREE.BufferAttribute( starSizes, 1 ) );

                var starMaterial = new THREE.ShaderMaterial( {
                    uniforms: {
                        color:   { type: "c", value: new THREE.Color( 0xffffff ) },
                        texture: { type: "t", value: new THREE.TextureLoader().load( "images/particle2.png" ) }
                    },
                    vertexShader: document.getElementById( 'vertexshader' ).textContent,
                    fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

                    alphaTest: 0.9,

                } );

                particles = new THREE.Points( bStars, starMaterial );
                group.add( particles );


                //--------------------- PARTICLES CLOSE AND CLICKABLE -------------------------- (make clickable)
                // particles2 = new THREE.Geometry();
                // var textureLoader = new THREE.TextureLoader();
                // sprite = textureLoader.load('textures/disc2.png');

                // for (var i = 0; i < 60; i++) {
                //     var vertex = new THREE.Vector3();

                //     //random * (max - min) + min
                //     vertex.x = Math.random() * 200 - 100;
                //     vertex.y = Math.random() * ( 20 - 1 ) + 1 ;
                //     //vertex.z = Math.random() * (-100 + 50 ) - 50;
                //     vertex.z = -100;

                //     particles2.vertices.push( vertex );
                // }

                // particleMaterial = new THREE.PointsMaterial({ 
                //     size: 5, 
                //     map: sprite, 
                //     blending: THREE.AdditiveBlending, 
                //     depthtest: false, 
                //     transparent: true 
                // });

                // particleMaterial.color.setHSL( 153, 204, 255 );

                // particleMesh = new THREE.Points( particles2, particleMaterial );
                // group.add( particleMesh );


                //CLICKABLE PARTICLES ------------------------

                var geometry2 = new THREE.BoxGeometry( 20, 20, 20 );

                for (var i = 0; i < 10; i++ ) {
                    var object = new THREE.Mesh( geometry2, new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, opacity: 0.5 } ) );

                    object.position.x = Math.random() * 200 - 100;
                    object.position.y = Math.random() * ( 50 - 1 ) + 1 ;
                    object.position.z = -200;

                    scene.add( object );
                    objects.push( object );
                }

                var PI2 = Math.PI * 2;
                particleMaterial = new THREE.PointsMaterial( {
                    color: 0x000000,
                    program: function ( context ) {
                        context.beginPath();
                        context.arc( 0, 0, 0.5, 0, PI2, true );
                        context.fill();
                    }
                });

                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();


                //CIRCLE
                var material = new THREE.MeshBasicMaterial({
                    color: 0xffffcc
                });

                var circleGeometry = new THREE.CircleGeometry( 2.3, 32 );
                circle = new THREE.Mesh( circleGeometry, material );
                circle.position.z = 0;
                circle.visible = false;
                scene.add( circle );


                //RENDERING------------------
                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor( 'rgb(0,0,0)' );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize ( window.innerWidth, window.innerHeight );
                document.getElementById( "container" ).appendChild( renderer.domElement );
                window.addEventListener( 'resize' , onWindowResize, false );

                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                renderer.sortObjects = false;

                raycaster = new THREE.Raycaster();

                mouse = new THREE.Vector2();

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                container.appendChild( stats.domElement );

                document.addEventListener('mousedown', onDocumentMouseDown, false);
                document.addEventListener('touchstart', onDocumentTouchStart, false);

                //document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                window.addEventListener( 'resize', onWindowResize, false );

            }

            //CLICKABLE
            function onDocumentTouchStart (event) {
                event.preventDefault();

                event.clientX = event.touches[0].clientX;
                event.clientY = event.touches[0].clientY;

                onDocumentMouseDown( event );
            }

            function onDocumentMouseDown( event ) {
                event.preventDefault();

                mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

                raycaster.setFromCamera( mouse, camera );

                var intersectParticle = raycaster.intersectObjects( objects );
                var intersectCircle = raycaster.intersectObject( circle ); 

                if ( intersectParticle.length > 0 ) {
                    intersectParticle[ 0 ].object.material.color.setHex( Math.random()* 3 * 0xffaabb);//0xffffff );

                    circle.visible = true;



                }

                if ( intersectCircle.length > 0 ) {
                    circle.visible = false;
                }
            }            


            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                requestAnimationFrame( animate );


                if (circle.radius < 60) { //circle.visible == true && 
                    circle.scale.radius += 0.2;
                    //circle.scale.x += 2;
                }

                //timeFrame = clock.getDelta(); 

                render();
                stats.update();

            }


            function render() {

                //particles.rotation.x += 0.0005;
                //particles.rotation.y += 0.001;

                earthMesh.rotation.z += ( mouseX - camera.position.x ) * 0.000001;

                camera.lookAt( scene.position );



                // SLUTADE HÄR ???????????????????????
                if (circle.visible == true && circle.radius < 6) {
                    circle.scale.radius += 2;
                    //circle.scale.x += 2;
                }

                //particleMesh.position.x += 0.0005;
                //particleMesh.position.z += 0.0005;
                //camera.position.x += ( mouseX - camera.position.x ) * 0.01;
                //camera.position.y += ( mouseY - camera.position.y ) * 0.095;

                //group.rotation.y -= 0.005;

                renderer.render( scene, camera );
            }

        </script>

    </body>

</html>